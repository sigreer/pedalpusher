#!/usr/bin/env python3
"""
PedalPusher filter for interception-tools.
Maps foot pedal key events to scripts and remapped keys.

Usage:
    pedalpusher-filter [--user USER] [--config PATH]

Options:
    --user USER     Run scripts as USER and use their config
    --config PATH   Use config directory at PATH (overrides --user for config)

Signals:
    SIGHUP          Reload configuration without restart
"""

import argparse
import os
import signal
import sys
import struct
import subprocess
import time
import yaml
from pathlib import Path

EVENT_SIZE = 24
EVENT_FORMAT = 'llHHi'

EV_KEY = 1
KEY_RELEASE = 0
KEY_PRESS = 1
KEY_REPEAT = 2

# Key codes for remapping (Linux input event codes)
# Full list: /usr/include/linux/input-event-codes.h
KEY_CODES = {
    # Function keys
    'F1': 59, 'F2': 60, 'F3': 61, 'F4': 62, 'F5': 63, 'F6': 64,
    'F7': 65, 'F8': 66, 'F9': 67, 'F10': 68, 'F11': 87, 'F12': 88,
    'F13': 183, 'F14': 184, 'F15': 185, 'F16': 186,
    'F17': 187, 'F18': 188, 'F19': 189, 'F20': 190,
    'F21': 191, 'F22': 192, 'F23': 193, 'F24': 194,
    # Letters
    'A': 30, 'B': 48, 'C': 46, 'D': 32, 'E': 18, 'F': 33,
    'G': 34, 'H': 35, 'I': 23, 'J': 36, 'K': 37, 'L': 38,
    'M': 50, 'N': 49, 'O': 24, 'P': 25, 'Q': 16, 'R': 19,
    'S': 31, 'T': 20, 'U': 22, 'V': 47, 'W': 17, 'X': 45,
    'Y': 21, 'Z': 44,
    # Numbers
    '1': 2, '2': 3, '3': 4, '4': 5, '5': 6,
    '6': 7, '7': 8, '8': 9, '9': 10, '0': 11,
    # Special keys
    'ENTER': 28, 'RETURN': 28,
    'ESCAPE': 1, 'ESC': 1,
    'TAB': 15,
    'SPACE': 57,
    'BACKSPACE': 14,
    'DELETE': 111,
    'INSERT': 110,
    'HOME': 102,
    'END': 107,
    'PAGEUP': 104, 'PAGE_UP': 104,
    'PAGEDOWN': 109, 'PAGE_DOWN': 109,
    'UP': 103, 'DOWN': 108, 'LEFT': 105, 'RIGHT': 106,
    'PAUSE': 119,
    'SCROLLLOCK': 70, 'SCROLL_LOCK': 70,
    'PRINTSCREEN': 99, 'PRINT_SCREEN': 99, 'SYSRQ': 99,
    # Modifiers
    'LEFT_CTRL': 29, 'LEFTCTRL': 29,
    'RIGHT_CTRL': 97, 'RIGHTCTRL': 97,
    'LEFT_SHIFT': 42, 'LEFTSHIFT': 42,
    'RIGHT_SHIFT': 54, 'RIGHTSHIFT': 54,
    'LEFT_ALT': 56, 'LEFTALT': 56,
    'RIGHT_ALT': 100, 'RIGHTALT': 100,
    'LEFT_META': 125, 'LEFTMETA': 125,
    'RIGHT_META': 126, 'RIGHTMETA': 126,
    # Media keys
    'MUTE': 113,
    'VOLUMEUP': 115, 'VOLUME_UP': 115,
    'VOLUMEDOWN': 114, 'VOLUME_DOWN': 114,
    'PLAYPAUSE': 164, 'PLAY_PAUSE': 164,
    'NEXTSONG': 163, 'NEXT_SONG': 163,
    'PREVIOUSSONG': 165, 'PREVIOUS_SONG': 165,
    'STOPCD': 166, 'STOP': 166,
    # Mouse buttons (EV_KEY type)
    'BTN_LEFT': 272, 'BTN_MOUSE': 272,
    'BTN_RIGHT': 273,
    'BTN_MIDDLE': 274,
    'BTN_SIDE': 275,
    'BTN_EXTRA': 276,
    'BTN_FORWARD': 277,
    'BTN_BACK': 278,
    'BTN_TASK': 279,
}

# Add KEY_ prefixed versions
KEY_CODES.update({f'KEY_{k}': v for k, v in list(KEY_CODES.items())})

# Global state for SIGHUP reload
reload_requested = False


def handle_sighup(signum, frame):
    """Handle SIGHUP for config reload."""
    global reload_requested
    reload_requested = True
    sys.stderr.write("pedalpusher: SIGHUP received, will reload config\n")


def find_config_and_user(args_user=None, args_config=None):
    """Find config directory and determine user. Returns (config_path, user)."""

    # Priority 1: Explicit --config path
    if args_config:
        config_dir = Path(args_config)
        user = args_user  # May be None, that's OK
        if (config_dir / 'config.yaml').exists():
            return config_dir, user
        sys.stderr.write(f"pedalpusher: Warning: --config path has no config.yaml: {config_dir}\n")

    # Priority 2: Explicit --user
    if args_user:
        for name in ['pedalpusher', 'footpedal']:
            path = Path(f'/home/{args_user}/.config/{name}')
            if (path / 'config.yaml').exists():
                return path, args_user
        # User specified but no config found - use default path
        return Path(f'/home/{args_user}/.config/pedalpusher'), args_user

    # Priority 3: PEDALPUSHER_USER environment variable
    env_user = os.environ.get('PEDALPUSHER_USER')
    if env_user and env_user != 'root':
        for name in ['pedalpusher', 'footpedal']:
            path = Path(f'/home/{env_user}/.config/{name}')
            if (path / 'config.yaml').exists():
                return path, env_user

    # Priority 4: SUDO_USER (for manual testing)
    sudo_user = os.environ.get('SUDO_USER')
    if sudo_user and sudo_user != 'root':
        for name in ['pedalpusher', 'footpedal']:
            path = Path(f'/home/{sudo_user}/.config/{name}')
            if (path / 'config.yaml').exists():
                return path, sudo_user

    # Priority 5: loginctl to find logged-in users
    try:
        result = subprocess.run(
            ['loginctl', 'list-users', '--no-legend'],
            capture_output=True, text=True, timeout=5
        )
        for line in result.stdout.strip().split('\n'):
            if line.strip():
                parts = line.split()
                if len(parts) >= 2:
                    user = parts[1]
                    if user != 'root':
                        for name in ['pedalpusher', 'footpedal']:
                            path = Path(f'/home/{user}/.config/{name}')
                            if (path / 'config.yaml').exists():
                                return path, user
    except Exception:
        pass

    # Priority 6: Scan /home for config directories (last resort)
    try:
        for home_dir in Path('/home').iterdir():
            if home_dir.is_dir():
                user = home_dir.name
                for name in ['pedalpusher', 'footpedal']:
                    path = home_dir / '.config' / name
                    if (path / 'config.yaml').exists():
                        return path, user
    except Exception:
        pass

    # Fallback
    return Path.home() / '.config' / 'pedalpusher', None


def load_config(config_dir):
    """Load configuration from YAML file."""
    config_file = config_dir / 'config.yaml'
    default_config = {
        'mappings': {},
        'scripts_dir': str(config_dir / 'scripts'),
        'user': None,
        'debounce': 0,
        'debug': False,
    }

    if config_file.exists():
        try:
            with open(config_file) as f:
                user_config = yaml.safe_load(f) or {}
                for key, value in user_config.items():
                    if key == 'mappings' and isinstance(value, dict):
                        default_config['mappings'].update(value)
                    else:
                        default_config[key] = value
        except Exception as e:
            sys.stderr.write(f"pedalpusher: Error loading config: {e}\n")

    return default_config


def run_script(script_path, user=None, event_type="unknown", config_dir=None):
    """Run a pedal script as the specified user."""
    if not os.path.exists(script_path):
        sys.stderr.write(f"pedalpusher: Script not found: {script_path}\n")
        return

    try:
        env = os.environ.copy()
        env['PEDAL_EVENT'] = event_type

        if user:
            env['HOME'] = f'/home/{user}'
            env['USER'] = user
            env['LOGNAME'] = user

            # Load environment file for GUI apps
            env_file = config_dir / 'env' if config_dir else None
            if env_file and env_file.exists():
                try:
                    with open(env_file, 'r') as f:
                        for line in f:
                            line = line.strip()
                            if '=' in line and not line.startswith('#'):
                                k, v = line.split('=', 1)
                                env[k] = v
                except Exception:
                    pass

        if os.getuid() == 0 and user and user != 'root':
            cmd = ['sudo', '-u', user, '-E', script_path]
        else:
            cmd = [script_path]

        subprocess.Popen(
            cmd, env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True
        )
    except Exception as e:
        sys.stderr.write(f"pedalpusher: Error running script: {e}\n")


def build_config_state(args_user, args_config):
    """Load config and build runtime state. Returns dict with all needed state."""
    config_dir, user = find_config_and_user(args_user, args_config)
    config = load_config(config_dir)

    # Expand ~ in scripts_dir
    scripts_dir_str = config['scripts_dir']
    if scripts_dir_str.startswith('~') and user:
        scripts_dir_str = scripts_dir_str.replace('~', f'/home/{user}', 1)
    scripts_dir = Path(scripts_dir_str)

    global_debounce = float(config.get('debounce', 0))
    debug = config.get('debug', False)

    # Override user from config if specified
    if config.get('user'):
        user = config['user']

    # Build key mappings
    key_mappings = {}
    for name, mapping in config['mappings'].items():
        key_code = mapping.get('key_code')
        if key_code is not None:
            key_mappings[key_code] = dict(mapping)
            key_mappings[key_code]['_name'] = name

    sys.stderr.write(f"pedalpusher: Config from {config_dir} (user={user})\n")
    sys.stderr.write(f"pedalpusher: Scripts dir: {scripts_dir}\n")
    sys.stderr.write(f"pedalpusher: Mappings: {[(k, m.get('on'), m.get('remap_to')) for k,m in key_mappings.items()]}\n")
    sys.stderr.write(f"pedalpusher: Debounce: {global_debounce}s, debug: {debug}\n")
    sys.stderr.write(f"pedalpusher: PID {os.getpid()} - send SIGHUP to reload config\n")

    return {
        'config_dir': config_dir,
        'user': user,
        'scripts_dir': scripts_dir,
        'global_debounce': global_debounce,
        'debug': debug,
        'key_mappings': key_mappings,
    }


def main():
    global reload_requested

    # Parse arguments
    parser = argparse.ArgumentParser(
        description='PedalPusher filter for interception-tools',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='Send SIGHUP to reload configuration without restart.'
    )
    parser.add_argument('--user', '-u', help='Run scripts as USER and use their config')
    parser.add_argument('--config', '-c', help='Use config directory at PATH')
    args = parser.parse_args()

    # Set up SIGHUP handler for config reload
    signal.signal(signal.SIGHUP, handle_sighup)

    # Initial config load
    state = build_config_state(args.user, args.config)

    pressed_keys = set()
    last_trigger_time = {}

    stdin = sys.stdin.buffer
    stdout = sys.stdout.buffer

    while True:
        # Check for reload request
        if reload_requested:
            reload_requested = False
            sys.stderr.write("pedalpusher: Reloading configuration...\n")
            try:
                state = build_config_state(args.user, args.config)
                sys.stderr.write("pedalpusher: Configuration reloaded successfully\n")
            except Exception as e:
                sys.stderr.write(f"pedalpusher: Failed to reload config: {e}\n")

        data = stdin.read(EVENT_SIZE)
        if not data or len(data) < EVENT_SIZE:
            break

        tv_sec, tv_usec, ev_type, ev_code, ev_value = struct.unpack(EVENT_FORMAT, data)

        # Debug logging
        if state['debug'] and ev_type == EV_KEY:
            val_name = {0: 'release', 1: 'press', 2: 'repeat'}.get(ev_value, str(ev_value))
            sys.stderr.write(f"pedalpusher: DEBUG key={ev_code} {val_name}\n")

        should_passthrough = True
        output_data = data

        if ev_type == EV_KEY and ev_code in state['key_mappings']:
            mapping = state['key_mappings'][ev_code]
            mapping_name = mapping.get('_name', 'unknown')
            trigger_on = mapping.get('on', 'press')
            debounce = float(mapping.get('debounce', state['global_debounce']))

            trigger = False
            event_type = "unknown"

            # Handle press/release/repeat
            is_press = ev_value == KEY_PRESS or (ev_value == KEY_REPEAT and ev_code not in pressed_keys)
            is_release = ev_value == KEY_RELEASE

            if is_press:
                pressed_keys.add(ev_code)
            if is_release:
                pressed_keys.discard(ev_code)

            # Determine if we should trigger
            if trigger_on == 'press' and is_press:
                trigger = True
                event_type = "press"
            elif trigger_on == 'release' and is_release:
                trigger = True
                event_type = "release"
            elif trigger_on == 'both':
                if is_press:
                    trigger = True
                    event_type = "press"
                elif is_release:
                    trigger = True
                    event_type = "release"

            # Apply debounce
            if trigger and debounce > 0:
                now = time.time()
                last_time = last_trigger_time.get(ev_code, 0)
                if now - last_time < debounce:
                    sys.stderr.write(f"pedalpusher: [{mapping_name}] Debounced {event_type}\n")
                    trigger = False
                else:
                    last_trigger_time[ev_code] = now

            # Run script if triggered
            if trigger:
                script_name = mapping.get('script', '')
                if script_name:
                    script_path = state['scripts_dir'] / script_name
                    sys.stderr.write(f"pedalpusher: [{mapping_name}] {event_type} -> {script_name}\n")
                    run_script(str(script_path), state['user'], event_type, state['config_dir'])

            should_passthrough = mapping.get('passthrough', False)

            # Handle key remapping
            remap_to = mapping.get('remap_to')
            if remap_to is not None and should_passthrough:
                # Resolve key name to code if string
                if isinstance(remap_to, str):
                    remap_to = KEY_CODES.get(remap_to.upper(), KEY_CODES.get(remap_to, remap_to))
                output_data = struct.pack(EVENT_FORMAT, tv_sec, tv_usec, ev_type, remap_to, ev_value)
                # Log all remaps when debug is enabled, otherwise just press/release
                if state['debug'] or is_press or is_release:
                    val_name = {0: 'rel', 1: 'press', 2: 'repeat'}.get(ev_value, '?')
                    sys.stderr.write(f"pedalpusher: [{mapping_name}] remap {ev_code} -> {remap_to} ({val_name})\n")

        if should_passthrough:
            stdout.write(output_data)
            stdout.flush()


if __name__ == '__main__':
    main()
